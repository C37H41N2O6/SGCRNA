var documenterSearchIndex = {"docs":
[{"location":"quickstart/#Quick-Start","page":"Quick Start","title":"Quick Start","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"SGCRNAs consists of five functions:","category":"page"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"CGM: Performs preprocessing for clustering.\nSpectralClustering: Carries out the clustering.\nSetNetwork: Prepares data for network graph visualisation.\nDrawNetwork: Generates the network graph.","category":"page"},{"location":"quickstart/#Example","page":"Quick Start","title":"Example","text":"","category":"section"},{"location":"quickstart/","page":"Quick Start","title":"Quick Start","text":"using CSV, DataFrames\nusing SGCRNAs\n\n# Load Data\nData = CSV.read(\"Result/Norm/normalizedCounts_coding.tsv\", header=1, comment=\"#\", delim='\\t', DataFrame);\n\n# Pre-proccessing\nCorData, GradData = CGM(Data.Symbol, Matrix(Data[:,5:end]), fn=\"Result/coding-FTEST\", mode=:FTEST);\n\n# Clustering\nclust, pos, edge_data = SpectralClustering(CorData, GradData);\n\n# Draw Network\nd = 1; k = maximum(clust[d]);\nnw, new_pos, cnctdf, new_clust, score = SetNetwork(edge_data, clust[d], pos, il=collect(1:k));\nDrawNetwork(\"Result/Fig/AllNetWork-0.5.png\", nw, new_pos, cnctdf, new_clust, k, node_scores=score, edge_mode=:ALL, edge_threshold=0.5);\n\n# module-phenomenon correlation\nPhen = CSV.read(\"SraRunTable.csv\", header=1, comment=\"#\", delim=',', DataFrame);\nsort!(Phen);\nData = innerjoin(Data, DataFrame(Symbol=names(edge_data)), on=:Symbol, order=:right);\nSGCRNAs.CorPhenMod(Data[:,5:end], Phen[:,[2,3,5]], new_clust, \"Result/Fig/CorPhenMod.png\");","category":"page"},{"location":"reference/#Reference","page":"Reference","title":"Reference","text":"","category":"section"},{"location":"reference/#SGCRNAs.CGM","page":"Reference","title":"SGCRNAs.CGM","text":"arguments\n\ngene::Vector: gene name list\ndata::Matrix: gene expression matrix\nthreshold::Float64: value for remove genes with more than a certain number of zeros; default: 0.5\nmode::Symbol: mode of measurement errors elimination\n:NONE -> measurement error is not considered (Select this option when there are sufficient number of samples; Default)\n:LESS -> defined as the value below the mode\n:SIGMA -> defined as the value below the 2σ(mode is considered as σ)\n:FTEST -> defined as the value below the significantly different from the mode by pval\nbinSize::Float64: histogram bin size used to determine measurement error when mode is other than :NONE; default: 0.01\npval::Float64: p-value for determining measurement error using :FTEST & Statistical tests of correlation coefficients; default: 0.05\npower::Float64: Power in statistical tests of correlation coefficients; default: 0.8\n\nreturns\n\nCorData: correlation matrix\nGradData: gradient matrix\n\n\n\n\n\n","category":"function"},{"location":"reference/#SGCRNAs.SpectralClustering","page":"Reference","title":"SGCRNAs.SpectralClustering","text":"arguments\n\ncor::DataFrame: dataframe of correlation matrix (return value of CGM())\ngrad::DataFrame: dataframe of gradient matrix (return value of CGM())\ntNodeNum::Int64: threshold of sub-cluster node number; default: 100\ndepthMaxv: Depth of sub-clusters; default: 5\npcas::Int64: pca dimention; default: 99\nitr::Int64: number of trials; default: 300\nseed::Int64: seed value of random number; default: 42 (Answer to the Ultimate Question of Life, the Universe, and Everything)\nnNeighbors::Int64: UMAP parameter; default: 40\nminDist::Float64: UMAP parameter; default: 0.1\nnormFlg::Bool: Whether to symmetrically normalize the Laplacian matrix; default: true\nrandNormFlg::Bool: Whether to random walk normalize the Laplacian matrix; default: false\n\nreturns\n\nclust: cluster number of each gene\npos: gene position for drawing network\nedgeScore: edge score for drawing network\n\n\n\n\n\n","category":"function"},{"location":"reference/#SGCRNAs.SetNetwork","page":"Reference","title":"SGCRNAs.SetNetwork","text":"arguments\n\ndf::DataFrame: dataframe of correlation matrix (return value of CGM())\nclust::Vector{Int64}: cluster number of each gene (one of return value of SpectralClustering())\npos::Matrix: gene position for drawing network (one of return value of SpectralClustering())\nil::Vector: module number list which you want to draw\n\nreturns\n\nnw: undirected graph\npos: node position\ncnctdf: converted correlation matrix\nclust: cluster number of each gene in network\nscore: node scores\n\n\n\n\n\n","category":"function"},{"location":"reference/#SGCRNAs.DrawNetwork","page":"Reference","title":"SGCRNAs.DrawNetwork","text":"arguments\n\nfn: figure save name\nnw: network graph (one of return value of SetNetwork())\npos: node position (one of return value of SetNetwork())\ncnctdf: converted correlation matrix (one of return value of SetNetwork())\nclust: cluster number of each gene in network (one of return value of SetNetwork())\nk: number of clusters\nnode_scores: weight of node\nnode_labels: label of node\nnode_scaler: multiple for node diameter adjustment; Default: 100\nedge_mode: mode of edges to be drawn\n:ALL -> All edges are drawn (Default)\n:N -> Only draw edges with negative values\n:P -> Only draw edges with positive values\nedge_threshold: Threshold value of edges to be drawn; Default: 0.0\nedge_scaler: multiple for edge thickness adjustment; Default: 5\nxsize, ysize: Size of the drawing area; Default: 100, 100\n\n\n\n\n\n","category":"function"},{"location":"reference/#SGCRNAs.CorPhenMod","page":"Reference","title":"SGCRNAs.CorPhenMod","text":"arguments\n\ndf1::DataFrame: dataframe of gene expression\ndf2::DataFrame: dataframe of Phenomenon\nclust::Vector{Int64}: cluster number of each gene (one of return value of SpectralClustering())\nfn::String: fig save name\ncor_mode::Symbol: mode of caluclation of correlation coefficient\n:ALL -> All three types are drawn (default)\n:A_AVG -> all gene average\n:P_AVG -> positive correlation gene average\n:N_AVG -> negative correlation gene average\n\n\n\n\n\n","category":"function"},{"location":"#SGCRNAs","page":"Home","title":"SGCRNAs","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SGCRNAs is a library for SGCRNA (Spectral-clustering Generalised Correlation Regression Network Analysis).   SGCRNA is a method for the analysis of co-expression networks, grounded in correlation and linear relationships. This method is applicable not only to transcriptomic data, but also to metagenomic, proteomic, and metabolomic variables, and accommodates a wide range of dataset types, including standard samples, time-course data, single-cell data, and spatially resolved datasets.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Download Julia 1.11 or later, preferably the current stable release. You can add SGCRNAs using Julia's package manager, by typing ] add SGCRNAs or using Pkg; Pkg.add(\"SGCRNAs\") in the Julia prompt.   We recommend installing the following optional packages:","category":"page"},{"location":"","page":"Home","title":"Home","text":"RCall: This is useful for executing R scripts within Julia, which is often necessary when performing Gene Ontology analysis on transcriptomic data.\nJLD2: Allows for the temporary saving of computational results.","category":"page"},{"location":"#Related-Publication","page":"Home","title":"Related Publication","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"If you use this package in your research, please cite the following paper: T. Osone, et al., SGCRNA: Spectral Clustering-Guided Co-Expression Network Analysis Without Scale-Free Constraints for Multi-Omic Data, bioRxiv, 2025. https://www.biorxiv.org/cgi/content/short/2025.04.27.650628v1","category":"page"},{"location":"tutorial/#Tutorial","page":"Tutorial","title":"Tutorial","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"In this tutorial, we use the dataset GSE114007, as described in the SGCRNA publication.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"RNA expression matrix\nclinical data","category":"page"},{"location":"tutorial/#1.-Preparation","page":"Tutorial","title":"1. Preparation","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Load the required packages and files.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"using CSV, DataFrames\nusing SGCRNAs\n\n# Load Data\nData = CSV.read(\"normalizedCounts_coding.tsv\", header=1, comment=\"#\", delim='\\t', DataFrame);\nPhen = CSV.read(\"SraRunTable.csv\", header=1, comment=\"#\", delim=',', DataFrame);","category":"page"},{"location":"tutorial/#2.-Pre-processing","page":"Tutorial","title":"2. Pre-processing","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Preprocessing of the data is performed using the CGM function.   The first argument takes a vector of variable names, and the second argument takes a matrix of values. The value matrix must have variables as rows and samples as columns.   An optional argument, mode (default: :NONE), can be set to :LESS, :SIGMA, or :FTEST. If any of these modes are specified, a plot will be generated and saved in the current directory, with the range of values to be removed highlighted in red. Regardless of which mode is selected, all modes other than :NONE will be included in the output figure.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"CorData, GradData = CGM(Data.Symbol, Matrix(Data[:,5:end]), mode=:FTEST);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: ) CorData is a DataFrame representing the correlation matrix, and GradData is a DataFrame representing the regression coefficient matrix.","category":"page"},{"location":"tutorial/#3.-Clustering","page":"Tutorial","title":"3. Clustering","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Clustering is performed using the results obtained in the previous step.   In general, it is not necessary to change the optional arguments. However, if the number of variables is small, consider reducing the values of tNodeNum (default: 100) and pcas (default: 99). It is recommended that both values be set to less than approximately one-tenth of the total number of variables, but no less than 3.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"clust, pos, edge_data = SpectralClustering(CorData, GradData);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"The clustering results are stored in clust.   Due to the sub-clustering process performed according to the conditions specified by the optional arguments of the function — tNodeNum (default: 100, the maximum number of nodes in a module) and depthMax (default: 5, the maximum number of sub-clustering iterations) — the results are returned as a vector of vectors. In most cases, you can simply use the vector at index 1. However, if you wish to perform more fine-grained clustering, you may use other elements as well.","category":"page"},{"location":"tutorial/#4.-Draw-Network","page":"Tutorial","title":"4. Draw Network","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Specify the modules you wish to visualise using SetNetwork, and draw the network graph with DrawNetwork. By passing a vector of module numbers to the optional argument il in SetNetwork, only the specified modules will be displayed. If il is not specified, all modules will be drawn.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"d = 1; k = maximum(clust[d]);\nnw, new_pos, cnctdf, new_clust, score = SetNetwork(edge_data, clust[d], pos, il=[1,13,62]);\nDrawNetwork(\"Result/Fig/NetWork.png\", nw, new_pos, cnctdf, new_clust, k, node_scores=score);","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"},{"location":"tutorial/#5.-Correlation-Between-Modules-and-Phenomena","page":"Tutorial","title":"5. Correlation Between Modules and Phenomena","text":"","category":"section"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"By comparing the modules with other parameters associated with the samples, it is possible to investigate which modules are related to specific parameters. In this example, the parameters include sex, osteoarthritis grade, and age.   It is important to note that, unlike the expression matrix, the parameter data is structured with samples as rows and parameters as columns.   Naturally, the order of the samples (i.e., the column order in the expression matrix) must match the order of the samples in the parameter data.","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"Data = innerjoin(Data, DataFrame(Symbol=unique(vcat(cnctdf.e1,cnctdf.e2))), on=:Symbol, order=:right);\nCorPhenMod(Data[:,5:end], Phen[:,[2,3,5]], new_clust, \"Result/Fig/CorPhenMod.png\");","category":"page"},{"location":"tutorial/","page":"Tutorial","title":"Tutorial","text":"(Image: )","category":"page"}]
}
